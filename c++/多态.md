# 多态

## 定义

多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。通俗来讲就是：有一个动物的大类，然后他有一个吃饭的特性函数，我们在使用的时候通过动物继承出了老虎、马、兔子等等派生类，他们吃的食物不同，因此这些派生类的吃饭的特性函数并重写了一遍，而最后当我们调用吃饭这个函数时，系统就会根据我们调用的对象来判断具体调用那个派生类的吃饭函数<br><br>

C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。上例子：

```c++
#include <iostream>

using namespace std;

class A
{
public:
 void virtual prt()
 {
  cout << "打印A" << endl;
 }
};

class B : public A
{
public:
 void prt()
 {
  cout << "打印B" << endl;
 }
};

class C : public A
{
public:
 void prt()
 {
  cout << "打印C" << endl;
 }
};

int main(void)
{
 A* a=(A*)new B();
 a->prt();
 a=(A*)new C();
 a->prt();
 return 0;
}
```

运行结果：

```shell
打印B
打印C
```

## 形成条件

形成多态必须具备三个条件：

1. 必须存在继承关系；

2. 继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字Virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）；

3. 存在基类类型的指针或者引用，通过该指针或引用调用虚函数；

## 回忆重写、重载、重定义

c++有重载、重写、重定义三个概念。

- 重载：要求两个函数的参数列表必须不同，但是不要求这两个函数必须是虚函数，它是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。这并不是多态的体现。
- 重写：子类中重写父类的虚函数，要求必须是虚函数且父类的虚函数必须有virtual关键字，函数的参数列表和返回值也必须相同。但子类中重写后的虚函数的访问修饰符可以不同。
- 重定义：其也是描述分别位于父类与子类中的同名函数的，但返回值可以不同。如果参数列表不同，这时子类中重定义的函数不论是否有virtual关键字，都会隐藏父类的同名函数。如果参数列表相同，但父类中的同名函数没有virtual关键字修饰，此时父类中的函数仍然被隐藏。

简单来讲：

- 重载：两个同名但不完全相同的函数，但实际是无关系的，相当于编号为1的李三和编号为2的李三。
- 重写：同名且外表完全相同的函数，有很多个李三，根据班级找人，对于当前对象来说，本派生类重写后的函数将父类的函数覆盖了。
- 重定义：把以前的函数删掉，重新定义一个，旧的函数从此开始已经不在了。

## 虚函数

虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重写基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。<br><br>

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。

### 半虚函数和纯虚函数

我们以上的例子均是半虚函数，我们在基类中定义了函数，并写出了函数体，而在派生类中，可以重写该函数也可以不写，不写则调用基类中写的。<br><br>

纯虚函数则是不在基类中编写函数体，要求派生类必须实现该方法。例子：

```c++
#include <iostream>

using namespace std;

class A
{
public:
 void virtual prt() = 0;
};

class B : public A
{
public:
 //不实现prt函数会报错：纯虚拟 函数 "A::prt" 没有强制替代项
 void prt()
 {
  cout << "打印B" << endl;
 }
};

class C : public A
{
public:
 void prt()
 {
  cout << "打印C" << endl;
 }
};

int main(void)
{
 A *a = (A *)new B();
 a->prt();
 a = (A *)new C();
 a->prt();
 return 0;
}
```

运行结果：

```shell
打印B
打印C
```

注意在一个类中如果存在未定义的虚函数，即纯虚函数，那么不能直接使用该类的实例，可以理解因为未定义 virtual 函数，其类是抽象的，无法实例化。以上是针对虚函数而言，普通的函数，即使我们只声明，不定义，也不会产生上述不可用的问题。

### 友元函数的虚拟问题

友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。

```c++
#include <iostream>

using namespace std;

class A
{
public:
 void serName(char n)
 {
  name = n;
 }
 virtual void prt()
 {
  cout << "A:" << name << endl;
 };
 friend void p(A *obj);

protected:
 char name;
};

void p(A *obj)
{
 cout << "调用p函数：" << endl;
 obj->prt();
}

class B : public A
{
public:
 void prt()
 {
  cout << "B:" << name << endl;
 }
};

int main(void)
{
 A *b=new B();
 b->serName('r');
 p(b);
 return 0;
}
```

运行结果：

```shell
调用p函数：
B:r
```
