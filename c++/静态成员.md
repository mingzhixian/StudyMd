# 静态成员

## 静态变量

在函数内部定义的变量，当程序执行到它的定义处时，编译器为它分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。所以产生了static，静态变量的作用范围不变，但是生命周期是从第一次定义直至程序结束。<br><br>

```c++
#include <iostream>
using namespace std;
void f1(){
    static int a=0;
    cout << a<< endl;
    a++;
}
int main(int argc, char const *argv[])
{
    f1();
    f1();
    f1();
    f1();
    f1();
    return 0;
}
```

运行结果：

```shell
0
1
2
3
4
```

另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

## 静态成员

当将类的某个数据成员声明为static时，该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类的对象无关。静态方法就是与该类相关的，是类的一种行为，而不是与该类的实例对象相关。
